(defun linear-sieve (n)
  (flet ((next (a i)
           (do ((j (1+ i) (1+ j)))
               ((or (= j (array-dimension a 0))
                    (= j (aref a j)))
                j))))
    (let ((a (make-array (1+ n) :element-type 'fixnum)))
      (do ((i 0 (1+ i)))
          ((> i n))
        (setf (aref a i) i))
      (do ((p-i 2 (next a p-i)))
           ((> (* (aref a p-i) (aref a p-i)) n) a)
        (do ((q-i 2 (next a q-i)))
            ((> (* (aref a p-i) (aref a q-i)) n) a)
          (let ((p (aref a p-i))
                (q (aref a q-i)))
            (do ((x (* p q) (* x p)))
                ((> x n))
              (setf (aref a x) p))))))))
(defun prime-fact (n s)
  "Prime factorizations of all numbers upto N,
S is an array of smallest prime factor for each numer."
  (flet ((exp-of (a p)
           "Exponent of P in factorization of A."
           (do ((x 1 (* p x))
                (k 0 (1+ k)))
               ((> (mod a (* x p)) 0) x k))))
    (let ((a (make-array (1+ n) :initial-element nil :element-type 'list)))
      (setf (aref a 0) '((1 . 1)))
      (setf (aref a 1) '((1 . 1)))
      (do ((i 2 (1+ i)))
          ((> i n) a)
        (do ((x i)
             (ps '()))
            ((= x 1) (setf (aref a i) ps))
          (let* ((p (aref s x))
                 (k (exp-of x p)))
            (setf x (/ x (expt p k)))
            (setf ps (cons (cons p k) ps))))))))
(defun counter (a f)
  (labels ((sub! (b i)
             (if (>= i (array-dimension b 0))
                 (throw 'sub-end nil)
                 (if (> (aref b i) 0)
                     (decf (aref b i))
                     (progn (setf (aref b i) (aref a i))
                            (sub! b (1+ i))))))
           (all-zero (b) (= 0 (reduce #'+ b))))
    (let ((b (make-array (array-dimensions a) :initial-contents a)))
      (catch 'sub-end
        (loop :do (progn
                    (funcall f b)
                    (sub! b 0)))))))
(defun all-div-pf (pf)
  "All divisors of a number with PF as prime factorization."
  (let* ((n (length pf))
         (es (make-array n :initial-contents (mapcar #'cdr pf)))
         (ps (make-array n :initial-contents (mapcar #'car pf)))
         result)
    (counter es (lambda (a)
                  (let ((num 1))
                    (dotimes (i n)
                      (setf num (* num (expt (aref ps i) (aref a i)))))
                    (setf result (cons num result)))))
    result))
(defun all-div (n)
  (let* ((s (linear-sieve n))
         (pf (prime-fact n s)))
    (dotimes (i (1+ n))
      (let ((pf (aref pf i)))
        (format t "~D: ~{~D~^ ~}~%" i (all-div-pf pf))))))

