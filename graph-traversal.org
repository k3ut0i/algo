* Graph Traversal                                                     :graph:
** BFS                                                                  :bfs:
Breadth first search.
#+name: bfs
#+begin_src c
  void print_bfs_from(int n, int m, int* es, int s){
    struct graph* g = graph_from_edges(n, m, es, 0); // undirected
    int queue[n], qs = 0, qe = 0, mark[n+1];
    for(int i = 0; i <= n; i++) mark[i] = 0;
    queue[qe++] = s;
    while(qs < qe){
      int cnode = queue[qs++]; // pop queue
      if(!mark[cnode]){
	il_t ns = g->adjacency_list[cnode];
	mark[cnode] = 1;
	fprintf(stdout, "%d ", cnode);
	while(ns!=NULL) {
	  if(!mark[ns->car]) queue[qe++] = ns->car; // push queue
	  ns = ns->cdr;
	}
      }
    }
    fprintf(stdout, "\n");
    destroy_graph(g);
  }

#+end_src
** DFS                                                                  :dfs:
Depth first search.
#+name: dfs
#+begin_src c
  void print_dfs_from(int n, int m, int* es, int s){
    struct graph* g = graph_from_edges(n, m, es, 0); // undirected
    int stack[n], sp = -1, mark[n+1];//, path[n], pi = -1;
    for(int i = 0; i <= n; i++) mark[i] = 0;
    stack[++sp] = s;
    while(sp >= 0){
      int cnode = stack[sp];
      if(mark[cnode]) sp--;
      else{
	il_t ns = g->adjacency_list[cnode];
	mark[cnode] = 1;
	fprintf(stdout, "%d ", cnode);
	while(ns!=NULL) {
	  if(!mark[ns->car]) stack[++sp] = ns->car;
	  ns = ns->cdr;
	}
      }
    }
    fprintf(stdout, "\n");
    destroy_graph(g);
  }
#+end_src

** Data Structures                                      :list:adjacency_list:
#+name: list
#+begin_src c
  typedef struct il{
    int car;
    struct il* cdr;
  } *il_t;

  il_t cons(int car, il_t cdr){
    il_t n = malloc(sizeof(*n));
    n->car = car, n->cdr = cdr;
    return n;
  }

  void destroy_il(il_t l){
    while(l != NULL){
      il_t n = l->cdr;
      free(l);
      l = n;
    }
  }

#+end_src

#+name: graph
#+begin_src c
  struct graph{
    int nnodes;
    il_t* adjacency_list;
  };

  struct graph* graph_from_edges(int nnodes, int nedges, int* edges, int directedp){
    struct graph* g = malloc(sizeof(*g));
    g->nnodes = nnodes;
    g->adjacency_list = malloc(sizeof(il_t)*(nnodes+1));
    for(int i = 0; i <= nnodes; i++) g->adjacency_list[i] = NULL;
    for(int i = 0; i < nedges; i++){
      int v1 = edges[2*i], v2 = edges[2*i+1];
      g->adjacency_list[v1] = cons(v2, g->adjacency_list[v1]);
      if(!directedp)
	g->adjacency_list[v2] = cons(v1, g->adjacency_list[v2]);
    }
    return g;
  }

  void destroy_graph(struct graph* g){
    for(int i = 0; i <= g->nnodes; i++) destroy_il(g->adjacency_list[i]);
    free(g->adjacency_list);
    free(g);
  }
#+end_src

** Main
#+begin_src c :noweb strip-export :tangle graph-traversal.c
  <<headers>>
  <<list>>
  <<graph>>
  <<dfs>>
  <<bfs>>
  int main(int argc, char* argv[]){
    if(argc != 2) {
      fprintf(stderr, "Usage: %s <node number>\n", argv[0]);
      return -1;
    }
    int source_node = atoi(argv[1]);
    int nnodes, nedges;
    fscanf(stdin, "%d %d", &nnodes, &nedges);
    int tmp;
    int edges[2*nedges];
    for(int i = 0; i < nedges; i++)
      fscanf(stdin, "%d %d %d", &edges[2*i], &edges[2*i+1], &tmp);
    print_dfs_from(nnodes, nedges, edges, source_node);
    print_bfs_from(nnodes, nedges, edges, source_node);
    return 0;
  }

#+end_src

#+name: headers
#+begin_src c
  #include<stdio.h>
  #include<stdlib.h>
#+end_src

** Lisp Implementation
Nodes are 1..n, ADJACENCY-LIST is an array of size n+1, where index i gives the list of nodes attached to node i.
#+name: dfs-spanning-tree
#+begin_src lisp
(defun dfs-st (adjacency-list)
  "A list of a edges in spanning tree generated by Depth-first search of the graph represented by ADJACENCY-LIST."
  (do ((stack (mapcar (lambda (n) (list n 1)) (aref adjacency-list 1)))
       (mark (let ((m (make-array (array-dimension adjacency-list 0)
                                  :element-type 'boolean
                                  :initial-element nil)))
               (prog2 (setf (aref m 1) t) m)))
       (edge-list nil))
      ((null stack) edge-list)
    (let* ((cnode (caar stack))
           (neighbours (remove-if (lambda (n) (aref mark n))
                                  (aref adjacency-list cnode))))
      (if (aref mark cnode)
          (setf stack (cdr stack))
          (setf edge-list (cons (car stack) edge-list)
                stack (append (mapcar (lambda (n) (list n cnode)) neighbours)
                              (cdr stack))
                (aref mark cnode) t)))))
#+end_src

#+name: bfs-spanning-tree
#+begin_src lisp
(defun bfs-st (adjacency-list)
  "Edges travelled when searching a graph breadth first."
  (let* ((start 0)
         (end 0)
         (q (make-array (* (1- (array-dimension adjacency-list 0))
                           (1- (array-dimension adjacency-list 0)))
                        :element-type 'list))
         (m (make-array (array-dimension adjacency-list 0)
                        :element-type 'boolean :initial-element nil)))
    (setf (aref m 1) t)
    (dolist (n (aref adjacency-list 1) q)
      (setf (aref q end) (list n 1)
            end (1+ end)))
    (do ((edge-list nil))
        ((= start end) edge-list)
      (let* ((cnode (car (aref q start)))
             (neighbours (remove-if (lambda (n) (aref m n))
                                    (aref adjacency-list cnode))))
        (when (not (aref m cnode))
          (setf edge-list (cons (aref q start) edge-list))
          (dolist (n neighbours)
            (setf (aref q end) (list n cnode)
                  end (1+ end))))
        (setf (aref m cnode) t)
        (incf start)))))
#+end_src

#+name: test-search-trees
#+begin_src lisp :noweb strip-export :exports both
<<dfs-spanning-tree>>
<<bfs-spanning-tree>>
(let ((al (make-array 7 :initial-contents '(nil
                                            (2 4 5 6)
                                            (1 4 6)
                                            (4 5)
                                            (1 2 3)
                                            (1 3 4)
                                            (1 2)))))
  (list (dfs-st al)
        (bfs-st al)))
#+end_src

#+RESULTS: test-search-trees
| (6 2) | (5 3) | (3 4) | (4 2) | (2 1) |
| (3 4) | (6 1) | (5 1) | (4 1) | (2 1) |
